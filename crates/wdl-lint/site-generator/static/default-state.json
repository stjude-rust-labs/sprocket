{"defaultTab":"wdl-lint","defaultTags":["Completeness","Naming","Spacing","Style","Clarity","Portability","Correctness","Sorting","Deprecated","Documentation","SprocketCompatibility"],"allLints":[{"id":"CallInputKeyword","tags":["Style","Deprecated"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that the <code>input:</code> keyword is not used in call statements when WDL version is 1.2 or later.</p>\n<h3>Why is this Bad?</h3>\n<p>Starting with WDL version 1.2, the <code>input:</code> keyword in call statements is optional. This specification change allows call inputs to be specified directly within the braces without the <code>input:</code> keyword, resulting in a cleaner and more concise syntax. This rule encourages adoption of the newer syntax when using WDL 1.2 or later.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    # In versions prior to WDL v1.2, the `input:` keyword\n    # was necessary in `call` statements.\n    call say_hello { input:\n        name = \"world\",\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    # This is correct for WDL v1.2 and later.\n    call say_hello {\n        name = \"world\",\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"CallInputSpacing","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that call inputs are spaced appropriately.</p>\n<h3>Why is this Bad?</h3>\n<p>When making calls from a workflow, it is more readable and easier to edit if the supplied inputs are each on their own line. When there is more than one input to a call statement, the <code>input:</code> keyword should follow the opening brace ({) and a single space, then each input specification should occupy its own line. This does inflate the line count of a WDL document, but it is worth it for the consistent readability. An exception can be made (but does not have to be made), for calls with only a single parameter. In those cases, it is permissable to keep the input on the same line as the call.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    call add {\n        input: lhs=10,rhs=20\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    call add { input:\n        lhs = 10,\n        rhs = 20,\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"CommandSectionIndentation","tags":["Spacing","Clarity","Correctness"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures consistent indentation (no mixed spaces/tabs) within command sections.</p>\n<h3>Why is this Bad?</h3>\n<p>Mixing indentation (tab and space) characters within the command line causes leading whitespace stripping to be skipped. Commands may be whitespace sensitive, and skipping the whitespace stripping step may cause unexpected behavior.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_greetings {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        # this line is prefixed with tabs\n\t\techo \"Hello, ~{name}!\"\n\t\t# this line is prefixed with spaces\n        echo \"Goodbye, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_greetings {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        # this line is prefixed with spaces\n        echo \"Hello, ~{name}!\"\n        # this line is prefixed with spaces\n        echo \"Goodbye, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"CommentWhitespace","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that WDL comments have the proper spacing.</p>\n<h3>Why is this Bad?</h3>\n<p>Comments on the same line as code should have 2 spaces before the # and one space before the comment text. Comments on their own line should match the indentation level around them and have one space between the # and the comment text. Keep in mind that even comments must be kept below the 90 character width limit.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Int user_count = 10 # The number of users\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Int user_count = 10  # The number of users\n\n    output {}\n}\n</code></pre>\n"},{"id":"ConciseInput","tags":["Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures concise input assignments are used (implicit binding when available).</p>\n<h3>Why is this Bad?</h3>\n<p>Redundant input assignments can be shortened in WDL versions &gt;=v1.1 with an implicit binding. For example, <code>{ input: a = a }</code> can be shortened to <code>{ input: a }</code>.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow hello {\n    input {\n        String name\n    }\n\n    # Since WDL v1.1, these explicit bindings can be shortened.\n    call say_hello {\n        name = name,\n    }\n}\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow hello {\n    input {\n        String name\n    }\n\n    # `name` can be passed in directly\n    call say_hello {\n        name,\n    }\n}\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"ConsistentNewlines","tags":["Spacing","Clarity","Portability"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that newline usage is consistent.</p>\n<h3>Why is this Bad?</h3>\n<p>Files should not mix <code>\\n</code> and <code>\\r\\n</code> line breaks. Pick one and use it consistently in your project.</p>\n"},{"id":"ContainerUri","tags":["Clarity","Portability"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that values for the <code>container</code> key within <code>runtime</code>/<code>requirements</code> sections are well-formed.</p>\n<h3>Why is this Bad?</h3>\n<p>This rule checks the following:</p>\n<ul>\n<li>Containers should have a tag, as container URIs with no tags have no expectation that the behavior of the containers won't change between runs.</li>\n<li>Further, immutable containers tagged with SHA256 sums are preferred. This is due to the requirement from the WDL specification that tasks produce functionally equivalent output across runs. When a mutable tag is used, there is a risk that changes to the container will cause different behavior between runs.</li>\n<li>Use of the 'any' container URI (<code>*</code>) within an array of container URIs is ambiguous and should be avoided.</li>\n<li>Empty container URI arrays are not disallowed by the specification but are ambiguous and should be avoided.</li>\n<li>An array of container URIs with a single element should be changed to a single string value.</li>\n</ul>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n\n    # No tag\n    requirements {\n        container: \"ubuntu\"\n    }\n}\n\ntask say_goodbye {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Goodbye, ~{name}!\"\n    &gt;&gt;&gt;\n\n    requirements {\n        container: [\"ubuntu:latest\"]\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n\n    requirements {\n        container: \"ubuntu:latest\"\n    }\n}\n\ntask say_goodbye {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Goodbye, ~{name}!\"\n    &gt;&gt;&gt;\n\n    requirements {\n        container: \"ubuntu:latest\"\n    }\n}\n</code></pre>\n"},{"id":"DeclarationName","tags":["Naming","Style","Clarity"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures declaration names do not redundantly include their type name.</p>\n<h3>Why is this Bad?</h3>\n<p>Declaration names should not include their type. This makes the code more verbose and often redundant. For example, use 'counter' instead of 'counter_int' or 'is_active' instead of 'is_active_bool'. Exceptions are made for String, File, and user-defined struct types, which are not flagged by this rule.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask example {\n    meta {}\n\n    input {\n        Int total_count_int\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask example {\n    meta {}\n\n    input {\n        Int total_count\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"DeprecatedObject","tags":["Deprecated"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that the deprecated <code>Object</code> types are not used.</p>\n<h3>Why is this Bad?</h3>\n<p>WDL <code>Object</code> types are officially deprecated and will be removed in the next major WDL release.</p>\n<p><code>Object</code>s existed prior to better containers, such as <code>Map</code>s and <code>Struct</code>s, being introduced into the language. Unfortunately, though these better alternatives did exist at the time of the v1.0 release, the type was not removed. It was later decided that <code>Object</code>s overlapped with <code>Map</code>s and <code>Struct</code>s in functionality, and the type was marked for removal.</p>\n<p>See this issue for more details: <a href=\"https://github.com/openwdl/wdl/pull/228\">https://github.com/openwdl/wdl/pull/228</a>.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Object person = object {\n        name: \"Jimmy\",\n        age: 55,\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nstruct Person {\n    String name\n    Int age\n}\n\nworkflow example {\n    meta {}\n\n    Person person = Person {\n        name: \"Jimmy\",\n        age: 55,\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"DeprecatedPlaceholder","tags":["Deprecated"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that deprecated expression placeholder options are not used.</p>\n<h3>Why is this Bad?</h3>\n<p>Expression placeholder options were deprecated in WDL v1.1 and will be removed in the next major WDL version.</p>\n<ul>\n<li><code>sep</code> placeholder options should be replaced by the <code>sep()</code> standard library function.</li>\n<li><code>true/false</code> placeholder options should be replaced with <code>if</code>/<code>else</code> statements.</li>\n<li><code>default</code> placeholder options should be replaced by the <code>select_first()</code> standard library function.</li>\n</ul>\n<p>This rule only evaluates for WDL V1 documents with a version of v1.1 or later, as this was the version where the deprecation was introduced.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Array[String] names = [\"James\", \"Jimmy\", \"John\"]\n    String names_separated = \"~{sep=\",\" names}\"\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Array[String] names = [\"James\", \"Jimmy\", \"John\"]\n    String names_separated = \"~{sep(\",\", names)}\"\n\n    output {}\n}\n</code></pre>\n"},{"id":"DescriptionLength","tags":["SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that description meta entries are not too long for display in Sprocket documentation.</p>\n<h3>Why is this Bad?</h3>\n<p>Descriptions should be kept short so that they can always render in full. If a <code>description</code> is too long, it will be clipped in some documentation contexts. <code>help</code> meta entries are never clipped and may be a better place for long form text.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        description: \"This is an example workflow. It is very important for documentation purposes, as it conveys a real workflow document without having to provide any implementation.\"\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        description: \"This is an example workflow.\"\n        # The `help` key can be used for extended descriptions\n        help: \"It is very important for documentation purposes, as it conveys a real workflow document without having to provide any implementation.\"\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"DocMetaStrings","tags":["SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that reserved meta keys have string values.</p>\n<h3>Why is this Bad?</h3>\n<p>Sprocket's documentation command reserves certain keys in <code>meta</code> and <code>parameter_meta</code> sections for documentation generation. These keys (<code>description</code>, <code>help</code>, <code>external_help</code>, <code>warning</code>, <code>category</code>, and <code>group</code>) must have <code>String</code> values. Using non-<code>String</code> values will cause the documentation to be rendered incorrectly or not at all. This rule ensures all reserved keys have <code>String</code> values for proper documentation generation.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        description: 123\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        description: \"123\"\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"DoubleQuotes","tags":["Style","Clarity"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that strings are defined using double quotes.</p>\n<h3>Why is this Bad?</h3>\n<p>All strings should be defined using double quotes. There is no semantic difference between single and double quotes in WDL, but double quotes should be used exclusively to ensure consistency and avoid any confusion.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow test {\n    meta {}\n\n    String name = 'Jimmy'\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow test {\n    meta {}\n\n    String name = \"Jimmy\"\n\n    output {}\n}\n</code></pre>\n"},{"id":"ElementSpacing","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that WDL elements are spaced appropriately.</p>\n<h3>Why is this Bad?</h3>\n<p>There should be a blank line between each WDL element at the root indentation level (such as the import block and any task/workflow definitions) and between sections of a WDL task or workflow. Never have a blank line when indentation levels are changing (such as between the opening of a workflow definition and the meta section). There should also never be blanks within a <code>meta</code>, <code>parameter_meta</code>, <code>input</code>, <code>output</code>, <code>runtime</code>, <code>requirements</code>, or <code>hints</code> section. For workflows, the <code>workflow body</code> includes any private declarations, call statements, conditional statements, and scatter statements. A <code>task body</code> is any and all private declarations. Within a workflow or task body, individual elements may optionally be separated by a blank line.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow determine_jimmy_age {\n\n    meta {\n\n        description: \"Determines the current age of Jimmy.\"\n\n        outputs: {\n            age: \"The age of Jimmy.\"\n\n        }\n\n    }\n\n    output {\n        Int age = 55\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow determine_jimmy_age {\n    meta {\n        description: \"Determines the current age of Jimmy.\"\n        outputs: {\n            age: \"The age of Jimmy.\"\n        }\n    }\n\n    output {\n        Int age = 55\n    }\n}\n</code></pre>\n"},{"id":"EndingNewline","tags":["Spacing","Portability"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that documents end with a single newline character.</p>\n<h3>Why is this Bad?</h3>\n<p>The file should end with one and only one newline character to conform to POSIX standards. See <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206\">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206</a>.</p>\n"},{"id":"ExpectedRuntimeKeys","tags":["Completeness","Deprecated"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that <code>runtime</code> sections have the appropriate keys.</p>\n<h3>Why is this Bad?</h3>\n<p>The behavior of this rule is different depending on the WDL version:</p>\n<p>For WDL v1.0 documents, the <code>docker</code> and <code>memory</code> keys are recommended, but the inclusion of any number of other keys is permitted.</p>\n<p>For WDL v1.1 documents:</p>\n<ul>\n<li>A list of mandatory, reserved keywords will be recommended for inclusion if they are not present. Here, 'mandatory' refers to the requirement that all execution engines support this keyâ€”not that the key must be present in the <code>runtime</code> section.</li>\n<li>Optional, reserved \"hint\" keys are also permitted but not flagged when they are missing (as their support in execution engines is not guaranteed).</li>\n<li>The WDL v1.1 specification deprecates the inclusion of non-reserved keys in a  <code>runtime</code> section. As such, any non-reserved keys will be flagged for removal.</li>\n</ul>\n<p>For WDL v1.2 documents and later, this rule does not evaluate because <code>runtime</code> sections were deprecated in this version.</p>\n<h3>Examples</h3>\n<p>The following is missing a mandatory key:</p>\n<pre><code class=\"language-wdl\">version 1.1\n\ntask missing_required_keys {\n    meta {}\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {}\n\n    runtime {}  # Missing `container` key\n}\n</code></pre>\n<p>The following has an unexpected key:</p>\n<pre><code class=\"language-wdl\">version 1.1\n\ntask unexpected_runtime_key {\n    meta {}\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {}\n\n    runtime {\n        container: \"ubuntu\"\n        foo: \"bar\"\n    }\n}\n</code></pre>\n"},{"id":"ExpressionSpacing","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that WDL expressions are properly spaced.</p>\n<h3>Why is this Bad?</h3>\n<p>Proper spacing is important for readability and consistency. This rule ensures that expressions are spaced properly.</p>\n<p>The following tokens should be surrounded by whitespace when used as an infix: <code>=</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code>.</p>\n<p>The following tokens should not be followed by whitespace when used as a prefix: <code>-</code>, and <code>!</code>.</p>\n<p>Opening brackets (<code>(</code>, <code>[</code>, and <code>{</code>) should not be followed by a space, but may be followed by a newline. Closing brackets (<code>)</code>, <code>]</code>, and <code>}</code>) should not be preceded by a space, but may be preceded by a newline.</p>\n<p>Sometimes a long expression will exceed the maximum line width. In these cases, one or more linebreaks must be introduced. Line continuations should be indented one more level than the beginning of the expression. There should never be more than one level of indentation change per-line.</p>\n<p>If bracketed content (things between <code>()</code>, <code>[]</code>, or <code>{}</code>) must be split onto multiple lines, a newline should follow the opening bracket, the contents should be indented an additional level, then the closing bracket should be de-indented to match the indentation of the opening bracket. If you are line splitting an expression on an infix operator, the operator and at least the beginning of the RHS operand should be on the continued line. (i.e. an operator should not be on a line by itself.)</p>\n<p>If you are using the <code>if...then...else...</code> construct as part of your expression and it needs to be line split, the entire construct should be wrapped in parentheses (<code>()</code>). The opening parenthesis should be immediately followed by a newline. <code>if</code>, <code>then</code>, and <code>else</code> should all start a line one more level of indentation than the wrapping parentheses. The closing parenthesis should be on the same level of indentation as the opening parenthesis. If you are using the <code>if...then...else...</code> construct on one line, it does not need to be wrapped in parentheses. However, if any of the 3 clauses are more complex than a single identifier, they should be wrapped in parentheses.</p>\n<p>Sometimes a developer will choose to line split an expression despite it being able to all fit on one line that is &lt;=90 characters wide. That is perfectly acceptable. There is 'wiggle' room allowed by the above rules. This is intentional, and allows developers to choose a more compact or a more spaced out expression.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask older_than_jimmy {\n    input {\n        Int age\n    }\n\n    Int jimmy_age = 55\n    command &lt;&lt;&gt;&gt;\n\n    output {\n        Boolean older = age&gt;jimmy_age\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask older_than_jimmy {\n    input {\n        Int age\n    }\n\n    Int jimmy_age = 55\n    command &lt;&lt;&gt;&gt;\n\n    output {\n        Boolean older = age &gt; jimmy_age\n    }\n}\n</code></pre>\n"},{"id":"HereDocCommands","tags":["Clarity","Correctness"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that tasks use heredoc syntax in command sections.</p>\n<h3>Why is this Bad?</h3>\n<p>Curly command blocks are no longer considered idiomatic WDL. Idiomatic WDL code uses heredoc command blocks instead. This is because curly command blocks create ambiguity with Bash syntax.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    meta {}\n\n    parameter_meta {}\n\n    command {\n        echo \"Hello, World!\"\n    }\n\n    output {}\n\n    runtime {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    meta {}\n\n    parameter_meta {}\n\n    command &lt;&lt;&lt;\n        echo \"Hello, World!\"\n    &gt;&gt;&gt;\n\n    output {}\n\n    runtime {}\n}\n</code></pre>\n"},{"id":"ImportPlacement","tags":["Clarity"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that imports are placed between the version statement and any document items.</p>\n<h3>Why is this Bad?</h3>\n<p>All import statements should follow the WDL version declaration with one empty line between the version and the first import statement.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n\nimport \"example2.wdl\"\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport \"example2.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"ImportSorted","tags":["Sorting"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that imports are sorted lexicographically.</p>\n<h3>Why is this Bad?</h3>\n<p>Imports should be sorted lexicographically to make it easier to find specific imports. This rule ensures that imports are sorted in a consistent manner. Specifically, the desired sort can be achieved with a GNU compliant <code>sort</code> and <code>LC_COLLATE=C</code>. No comments are permitted within an import statement.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport \"orange.wdl\"\nimport \"apple.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport \"apple.wdl\"\nimport \"orange.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"ImportWhitespace","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that there is no extraneous whitespace between or within imports.</p>\n<h3>Why is this Bad?</h3>\n<p>Imports should be grouped together without any whitespace between them. Each import statement should be contained to one line. No whitespace should come before the start of each import statement. One literal space should be between the <code>import</code> keyword and the import path. If the <code>alias</code> or <code>as</code> keywords are present, they should be separated from the previous and next words by exactly one space. If separation between imports is needed, it should be done with one or more comments labelling groups of imports. Extraneous whitespace between and within imports makes code harder to parse and understand.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport    \"apple.wdl\" as   apples\n\nimport \"orange.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport \"apple.wdl\" as apples\nimport \"orange.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"InputName","tags":["Naming","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures input names are meaningful (e.g. not generic like 'input', 'in', or too short).</p>\n<h3>Why is this Bad?</h3>\n<p>Any input name matching these regular expressions will be flagged: <a href=\"https://regex101.com/r/V0AFIG/2\"><code>/^[iI]n[A-Z_]/</code></a>, <a href=\"https://regex101.com/r/Ox8oYb/1\"><code>/^input/i</code></a> or <a href=\"https://regex101.com/r/IS1d49/1\"><code>/^..?$/</code></a>.</p>\n<p>It is redundant and needlessly verbose to use an input's name to specify that it is an input. Input names should be short yet descriptive. Prefixing a name with in or input adds length to the name without adding clarity or context. Additionally, names with only 2 characters can lead to confusion and obfuscates the content of an input. Input names should be at least 3 characters long.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String input_name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{input_name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    meta {\n        description: \"Says hello for the given name\"\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"InputSorted","tags":["Sorting"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that input declarations are sorted.</p>\n<h3>Why is this Bad?</h3>\n<p>Each input declaration section should be sorted. This rule enforces an opinionated sorting.</p>\n<p>It first sorts by:</p>\n<ol>\n<li>required inputs</li>\n<li>optional inputs without defaults</li>\n<li>optional inputs with defaults</li>\n<li>inputs with a default value</li>\n</ol>\n<p>Then by the type:</p>\n<ol>\n<li>File</li>\n<li>Array[*]+</li>\n<li>Array[*]</li>\n<li>struct</li>\n<li>Object</li>\n<li>Map[*, *]</li>\n<li>Pair[*, *]</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Float</li>\n<li>Int</li>\n</ol>\n<p>For ordering of the same compound type (Array[<em>], Map[</em>, <em>], Pair[</em>, *]), drop the outermost type(Array, Map, etc.) and recursively apply above sorting on the first inner type *, with ties brokenby the second inner type. Continue this pattern as far as possible. Once this ordering is satisfied,it is up to the developer for final order of inputs of the same type.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask describe_person {\n    input {\n        ?File target = stdout()\n        ?Int age\n        String name\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask describe_person {\n    input {\n        String name\n        ?Int age\n        ?File target = stdout()\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"KnownRules","tags":["Clarity","Correctness","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures only known rules are used in lint directives.</p>\n<h3>Why is this Bad?</h3>\n<p>When writing WDL, lint directives are used to suppress certain rules. If a rule is unknown, nothing will be suppressed. This rule flags unknown rules as they are often mistakes.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">#@ except: LintThatDoesNotExit\n\nversion 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"LineWidth","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that lines do not exceed a certain width.</p>\n<h3>Why is this Bad?</h3>\n<p>Lines should not exceed a certain width to make it easier to read and understand the code. Code within the either the meta or parameter meta sections is not checked. Comments are included in the line width check. The current maximum width is 90 characters.</p>\n"},{"id":"LintDirectiveFormatted","tags":["Clarity","Correctness","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures lint directives are correctly formatted.</p>\n<h3>Why is this Bad?</h3>\n<p>This rule checks that lint directives are properly formatted.\nLint directives must be on their own line, only preceded by whitespace. They should follow the pattern <code>#@ &lt;directive&gt;: &lt;value&gt;</code> <em>exactly</em>. Currently the only accepted lint directive is <code>except</code>. For example, <code>#@ except: LintDirectiveFormatted</code>.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">#@except: SnakeCase\n#@ ecept: LineWidth\n\nversion 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:\n#@ except: SnakeCase\n#@ except: LineWidth</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"LintDirectiveValid","tags":["Clarity","Correctness","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures lint directives are placed correctly to have the intended effect.</p>\n<h3>Why is this Bad?</h3>\n<p>When writing WDL, lint directives are used to suppress certain rules. If a lint directive is misplaced, it will have no effect. This rule flags misplaced lint directives to ensure they are in the correct location.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    output {\n        # MatchingOutputMeta exceptions aren't valid\n        # in this context\n        #@ except: MatchingOutputMeta\n        String name = \"Jimmy\"\n    }\n}\n</code></pre>\n<p>Use instead:\nversion 1.2</p>\n<p>#@ except: MatchingOutputMeta\nworkflow example {\nmeta {}</p>\n<pre><code>output {\n    String name = \"Jimmy\"\n}\n</code></pre>\n<p>}</p>\n<pre><code></code></pre>\n"},{"id":"MatchingOutputMeta","tags":["Completeness","Documentation","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that each output field is documented in the meta section under <code>meta.outputs</code>.</p>\n<h3>Why is this Bad?</h3>\n<p>The meta section should have an <code>outputs</code> key that is an object and contains keys with descriptions for each output of the task/workflow. These must match exactly. i.e. for each named output of a task or workflow, there should be an entry under <code>meta.outputs</code> with that same name. Additionally, these entries should be in the same order (that order is up to the developer to decide). No extraneous <code>meta.outputs</code> entries are allowed.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask generate_greeting {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {\n        String greeting = \"Hello, ~{name}!\"\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask generate_greeting {\n    meta {\n        outputs: {\n            greeting: \"The generated greeting for the provided name\"\n        }\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {\n        String greeting = \"Hello, ~{name}!\"\n    }\n}\n</code></pre>\n"},{"id":"MetaDescription","tags":["Completeness","Documentation","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures the <code>meta</code> section contains a <code>description</code> key.</p>\n<h3>Why is this Bad?</h3>\n<p>Each task, workflow, and struct should have a description in the meta section. The description should be short, written in active voice, and be in complete sentences. More detailed information can be included in the <code>help</code> key.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    meta {\n        description: \"Says hello for the given name\"\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"MetaKeyValueFormatting","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that arrays and objects in <code>meta</code> and <code>parameter_meta</code> sections have one element per line and are indented correctly.</p>\n<h3>Why is this Bad?</h3>\n<p>All lists and objects in the <code>meta</code> and <code>parameter_meta</code> sections should have one element per line (i.e. newline separate elements). A key/value pair are considered one element if the value is atomic (i.e. not a list or an object). Otherwise have the key and opening bracket on the same line; subsequently indent one level; put one value per line; and have the closing bracket on its own line at the same indentation level of the key.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        names: [\"James\",\n        \"Jimmy\", \"John\"]\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {\n        names: [\n            \"James\",\n            \"Jimmy\",\n            \"John\"\n        ]\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"MetaSections","tags":["Completeness","Clarity","Documentation"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that tasks and workflows have the required <code>meta</code> and <code>parameter_meta</code> sections.</p>\n<h3>Why is this Bad?</h3>\n<p>It is important that WDL code is well-documented. Every task and workflow should have both a meta and parameter_meta section. Tasks without an <code>input</code> section are permitted to skip the <code>parameter_meta</code> section.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    meta {\n        description: \"Says hello for the given name\"\n    }\n    \n    parameter_meta {\n        name: \"The name of the person to greet\"\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"OutputName","tags":["Naming","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures output names are meaningful (e.g. not generic like 'output', 'out', or too short).</p>\n<h3>Why is this Bad?</h3>\n<p>Any output name matching these regular expressions will be flagged: <a href=\"https://regex101.com/r/r6v2fL/1\"><code>/^[oO]ut[A-Z_]/</code></a>, <a href=\"https://regex101.com/r/vybrEi/1\"><code>/^output/i</code></a> or <a href=\"https://regex101.com/r/5yWAfk/1\"><code>/^..?$/</code></a>.</p>\n<p>It is redundant and needlessly verbose to use an output's name to specify that it is an output. Output names should be short yet descriptive. Prefixing a name with out or output adds length to the name without adding clarity or context. Additionally, names with only 2 characters can lead to confusion and obfuscates the content of an output. Output names should be at least 3 characters long.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask generate_greeting {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {\n        String output_greeting = \"Hello, ~{name}!\"\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask generate_greeting {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {\n        String greeting = \"Hello, ~{name}!\"\n    }\n}\n</code></pre>\n"},{"id":"ParameterMetaMatched","tags":["Completeness","Sorting","Documentation","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that inputs have a matching entry in a <code>parameter_meta</code> section.</p>\n<h3>Why is this Bad?</h3>\n<p>Each input parameter within a task or workflow should have an associated <code>parameter_meta</code> entry with a detailed description of the input. Non-input keys are not permitted within the <code>parameter_meta</code> block.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    parameter_meta {\n        name: \"The name of the person to greet\"\n        does_not_exist: \"This is not a real parameter\"\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    parameter_meta {\n        name: \"The name of the person to greet\"\n    }\n\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"PascalCase","tags":["Naming","Style","Clarity"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that structs are defined with PascalCase names.</p>\n<h3>Why is this Bad?</h3>\n<p>Struct names should be in PascalCase. Maintaining a consistent naming convention makes the code easier to read and understand.</p>\n<h3>Examples</h3>\n<p>Struct names should be in PascalCase:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nstruct registered_user {\n    String name\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nstruct RegisteredUser {\n    String name\n}\n</code></pre>\n"},{"id":"PreambleCommentPlacement","tags":["Style","Clarity","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that preamble comments are inside the preamble.</p>\n<h3>Why is this Bad?</h3>\n<p>Preamble comments should only appear in the preamble section of a WDL document. This rule ensures that freestanding double-pound comments (<code>##</code>) are not used after the version statement.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\n## This is a preamble comment!\n##\n## This document provides the `example` workflow.\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">## This is a preamble comment!\n##\n## This document provides the `example` workflow.\n\nversion 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"PreambleFormatted","tags":["Spacing","Style","SprocketCompatibility"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that documents have correct formatting in the preamble.</p>\n<h3>Why is this Bad?</h3>\n<p>The document preamble is defined as anything before the version declaration statement and the version declaration statement itself. Only comments and whitespace are permitted before the version declaration.</p>\n<p>All comments in the preamble should conform to one of two special formats: lint directives or preamble comments.</p>\n<p>This rule enforces the following formatting requirements:</p>\n<ol>\n<li>\n<p>Comments in the preamble should be full line comments (no whitespace before the comment).</p>\n</li>\n<li>\n<p>If lint directives are present, they should be at the absolute beginning of the document.</p>\n</li>\n<li>\n<p>Multiple lint directives are permitted, but they should not be interleaved with preamble comments or blank lines.</p>\n</li>\n<li>\n<p>A space should follow the double-pound-sign (<code>##</code>) if there is any text within the preamble comment.</p>\n</li>\n<li>\n<p>\"Empty\" preamble comments (<code>##</code>) are permitted and should not have any whitespace following the <code>##</code>.</p>\n</li>\n<li>\n<p>Comments beginning with 3 or more pound signs before the version declaration are not permitted.</p>\n</li>\n<li>\n<p>All preamble comments should be in a single block without blank lines.</p>\n</li>\n<li>\n<p>Following the preamble comment block, there should always be a blank line before the version statement.</p>\n</li>\n<li>\n<p>When transitioning from lint directives to preamble comments, there should be exactly one blank line.</p>\n</li>\n<li>\n<p>Both lint directives and preamble comments are optional, and if they are not present, there should be no comments or whitespace before the version declaration.</p>\n</li>\n</ol>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">#@ except: LineWidth\n##This is a preamble comment!\n##\n##This document provides the `example` workflow.\n\nversion 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">#@ except: LineWidth\n\n## This is a preamble comment!\n##\n## This document provides the `example` workflow.\n\nversion 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"RedundantNone","tags":["Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Flags redundant assignment of <code>None</code> to optional inputs.</p>\n<h3>Why is this Bad?</h3>\n<p>The specification states that an optional input declaration (e.g., <code>String? foo</code>) is implicitly initialized to <code>None</code> if no default is provided. Therefore explicitly writing <code>String? foo = None</code> is equivalent to <code>String? foo</code> but adds unnecessary verbosity.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    input {\n        String? name = None\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    input {\n        String? name\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"RequirementsSection","tags":["Completeness","Portability","Deprecated"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that tasks have a <code>requirements</code> section (for WDL v1.2 and beyond).</p>\n<h3>Why is this Bad?</h3>\n<p>Tasks that don't declare <code>requirements</code> sections are unlikely to be portable.</p>\n<p>For tasks that <em>should</em> contain a <code>requirements</code> section but a <code>runtime</code> section exists instead, the <code>runtime</code> section is flagged as deprecated.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n\n    requirements {\n        container: \"ubuntu:latest\"\n    }\n}\n</code></pre>\n"},{"id":"RuntimeSection","tags":["Completeness","Portability"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that tasks have a <code>runtime</code> section (for WDL v1.1 and prior).</p>\n<h3>Why is this Bad?</h3>\n<p>Tasks that don't declare <code>runtime</code> sections are unlikely to be portable.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.1\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.1\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n\n    runtime {\n        container: \"ubuntu:latest\"\n    }\n}\n</code></pre>\n"},{"id":"SectionOrdering","tags":["Style","Sorting"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that all sections are in the correct order.</p>\n<h3>Why is this Bad?</h3>\n<p>For workflows, if present, the following sections must be in this order: meta, parameter_meta, input, (body), output. \"(body)\" represents all calls and declarations.</p>\n<p>For tasks, if present, the following sections must be in this order: meta, parameter_meta, input, (private declarations), command, output, runtime, requirements, hints.</p>\n<p>For structs, if present, the following sections must be in this order: meta, parameter_meta, members.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow hello {\n    input {\n        String name\n    }\n\n    meta {\n        description: \"Says hello\"\n    }\n\n    parameter_meta {\n        name: \"The name of the target\"\n    }\n\n    call say_hello {\n        name\n    }\n\n    output {}\n}\n\ntask say_hello {\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n\n    input {\n        String name\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow hello {\n    meta {\n        description: \"Says hello\"\n    }\n\n    parameter_meta {\n        name: \"The name of the target\"\n    }\n\n    input {\n        String name\n    }\n\n    call say_hello {\n        name\n    }\n\n    output {}\n}\n\ntask say_hello {\n    input {\n        String name\n    }\n\n    command &lt;&lt;&lt;\n        echo \"Hello, ~{name}!\"\n    &gt;&gt;&gt;\n}\n</code></pre>\n"},{"id":"ShellCheck","tags":["Correctness"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that command blocks are free of ShellCheck violations.</p>\n<h3>Why is this Bad?</h3>\n<p><a href=\"https://shellcheck.net\">ShellCheck</a> is a static analysis tool and linter for sh / bash. The lints provided by ShellCheck help prevent common errors and pitfalls in your scripts. Following its recommendations will increase the robustness of your command sections.</p>\n"},{"id":"SnakeCase","tags":["Naming","Style","Clarity"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that tasks, workflows, and variables are defined with snake_case names.</p>\n<h3>Why is this Bad?</h3>\n<p>Workflow, task, and variable names should be in snake case. Maintaining a consistent naming convention makes the code easier to read and understand.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow ProcessData {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow process_data {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"TodoComment","tags":["Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Flags TODO statements in comments to ensure they are not forgotten.</p>\n<h3>Why is this Bad?</h3>\n<p>When writing WDL, future tasks are often marked as <code>TODO</code>. This indicates that the implementor intended to go back to the code and handle the todo item. TODO items should not be long-term fixtures within code and, as such, they are flagged to ensure none are forgotten.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\n# The following comment will be flagged:\n# TODO: Implement this workflow\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"TrailingComma","tags":["Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that lists and objects have a trailing comma and that there's not extraneous whitespace and/or comments before the trailing comma.</p>\n<h3>Why is this Bad?</h3>\n<p>All items in a comma-delimited object or list should be followed by a comma, including the last item. An exception is made for lists for which all items are on the same line, in which case there should not be a trailing comma following the last item. Note that single-line lists are not allowed in the <code>meta</code> or <code>parameter_meta</code> sections. This method checks <code>arrays</code> and <code>objects</code> in <code>meta</code> and <code>parameter_meta</code> sections. It also checks <code>call</code> input blocks as well as <code>Array</code>, <code>Map</code>, <code>Object</code>, and <code>Struct</code> literals.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Map[String, Int] ages = {\n        \"James\": 34,\n        \"Jimmy\": 55 # No trailing comma\n    }\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    Map[String, Int] ages = {\n        \"James\": 34,\n        \"Jimmy\": 55,\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"VersionStatementFormatted","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures the <code>version</code> statement is correctly formatted.</p>\n<h3>Why is this Bad?</h3>\n<p>The version statement should be formatted correctly. This rule checks that the version statement is followed by a blank line and that there is exactly one space between 'version' and the version number. It also checks that if there are comments before the version statement, they are separated by exactly one blank line. If there are no comments, there should be no whitespace before the version statement.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version    1.2\nworkflow formatting {\n    meta {}\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow formatting {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"Whitespace","tags":["Spacing","Style"],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that a document does not contain undesired whitespace.</p>\n<h3>Why is this Bad?</h3>\n<p>Whitespace should be used judiciously. Spurious whitespace can cause issues with parsing, automation, and rendering. There should never be trailing whitespace at the end of lines and blank lines should be completely empty with no whitespace characters between newlines. There should be at most one empty line in a row.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n# Extra trailing whitespace\n\n    output {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"}],"allAnalysisLints":[{"id":"UnnecessaryFunctionCall","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that function calls are necessary.</p>\n<h3>Why is this Bad?</h3>\n<p>Unnecessary function calls may impact evaluation performance.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    # Calls to `defined` on values that are statically\n    # known to be non-None are unnecessary.\n    Boolean exists = defined(\"hello\")\n\n    output {}\n}\n</code></pre>\n"},{"id":"UnusedCall","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that outputs of a call statement are used in the declaring workflow.</p>\n<h3>Why is this Bad?</h3>\n<p>Unused calls may cause unnecessary consumption of compute resources.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    # The output of `do_work` is never used\n    call do_work\n\n    output {}\n}\n\ntask do_work {\n    command &lt;&lt;&lt;&gt;&gt;&gt;\n\n    output {\n        Int x = 0\n    }\n}\n</code></pre>\n"},{"id":"UnusedDeclaration","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that private declarations in tasks or workspaces are used within the declaring task or workspace.</p>\n<h3>Why is this Bad?</h3>\n<p>Unused private declarations degrade evaluation performance and reduce the clarity of the code.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    String unused = \"this will produce a warning\"\n\n    output {}\n}\n</code></pre>\n"},{"id":"UnusedImport","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that import namespaces are used in the importing document.</p>\n<h3>Why is this Bad?</h3>\n<p>Imported WDL documents should be used in the document that imports them. Unused imports impact parsing and evaluation performance.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nimport \"example2.wdl\"\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"},{"id":"UnusedInput","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Ensures that task or workspace inputs are used within the declaring task or workspace.</p>\n<h3>Why is this Bad?</h3>\n<p>Unused inputs degrade evaluation performance and reduce the clarity of the code. Unused file inputs in tasks can also cause unnecessary file localizations.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\">version 1.2\n\nworkflow example {\n    meta {}\n\n    inputs {\n        String unused\n    }\n\n    output {}\n}\n</code></pre>\n"},{"id":"UsingFallbackVersion","tags":[],"descriptionHtml":"<h3>What it Does</h3>\n<p>Warns if interpretation of a document with an unsupported version falls back to a default.</p>\n<h3>Why is this Bad?</h3>\n<p>A document with an unsupported version may have unpredictable behavior if interpreted as a different version.</p>\n<h3>Examples</h3>\n<pre><code class=\"language-wdl\"># Not a valid version. If a fallback version is configured,\n# the document will be interpreted as that version.\nversion 3.0\n\nworkflow example {\n    meta {}\n\n    output {}\n}\n</code></pre>\n"}],"lintVersion":"wdl-lint @ main (rev ccd2fe70)","analysisVersion":"wdl-analysis @ main (rev ccd2fe70)"}